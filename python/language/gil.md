---
title: GIL锁
date: 2021-3-26 17:10:00
tags: [python]
---

[原文](https://realpython.com/python-gil/#reader-comments)

Python的GIL（Global Interpreter Lock），简单来讲，是一个用来保证同时只有一个线程拥有控制权的互斥锁。

这意味着在任何一个时间点，只有一个线程在执行。对于单线程序来说GIL没有影响，但对于CPU密集的多线操作影响比较明显。

### GIL解决了Python的什么问题

Python通过引用计数的方式进行内存管理。这表示创建的对象都会有一个变量用来保存计数，当计数归零时释放对象。

问题来了，当有多个线程时，这个引用计数变量就需要得到保护，避免计数出现错误，从而导致内存泄漏或者释放正在使用的对象。

一种解决方案是在每个对象中添加引用计数锁，但是一个以上的锁可能导致死锁，另一个问题是重复申请和释放锁会导致性能下降。

GIL解释器锁增加的一条规则，任何字节码执行时都需要获取GIL锁。因为只有一个锁，避免了死锁。也不会带来很高的性能开销。但是这使得CPU密集操作变为了单线操作。

GIL实现起来非常简单并且很容易添加到Python。因为只有一个锁需要管理，单线程的性能非常好。

那些线程不安全的C库很容易集成到Python，而这些C扩展成为Python受社区欢迎的原因。

### 对多线程序的影响

CPU密集型程序和I/O密集型程序在多线程下的工作情况是有区别的。

CPU密集型程序是将CPU使用到极限的程序，包括像矩阵乘法、搜索、图像处理这样的数学计算。

I/O密集型程序是那些大部分时间都在等待I/O的程序，例如读取文件、数据库、网络等等。

GIL对I/O密集型程序的性能没有太大的影响，因为在等待I/O时，锁是在线程间共享的。

但是对于CPU密集型程序，由于增加锁和释放锁的开销，甚至性能不如单线执行。

### 为什么GIL锁还没有被移除

GIL显然是可以被移除的，过去开发人员和研究人员已经做过很多次了，但是这些都会破坏现有的C扩展，因为这些C扩展严重依赖于GIL。

其中有些解决方案会降低单线程和多线程I/O绑定程序的性能。

### 如何处理Python的GIL

+ 多进程代替多线程
+ 使用其他Python解析器（Jython，IronPython，PyPy）
+ 等等党（等社区大佬解决这个问题）